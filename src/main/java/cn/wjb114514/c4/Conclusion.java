package cn.wjb114514.c4;

/**
 * 概念剖析
 * stream vs channel :
 * stream不会自动缓冲数据 channel会利用系统提供的发送缓冲区和接收缓冲区[更为底层]
 * stream仅支持阻塞API，channel同时支持阻塞/非阻塞API，网络channel可以配合selector进行多路复用。
 * 二者均为全双工：即读写同时进行。
 *
 * 读取操作的过程
 * 用户态[channel.read()] ===> 从网络上读取数据需要依赖硬件接受和操作系统调度。 因此需要迁移到内核态
 * 内核态 : 1.等待数据[等待要读取的数据准备好] 2.复制数据[把数据从网卡读到内存里]
 * ==> 返回用户态，用户态可以操作读取到的数据
 *
 * IO模型：
 * 阻塞IO  ==> 内核态需要等待数据，在等待数据的过程里，用户线程是阻塞的[因为内核态迟迟不切换回来]，什么也干不了
 * 非阻塞IO ==> 内核态和用户态 多次切换，用户态在内核态等待数据的过程中是不阻塞的，不断的切换用户态和内核态，如果发现目前仍然在等待数据，就空手而归
 * 但是如果发现有数据了，就会等待内核态完成数据的拷贝，然后把拷贝好的数据拿回来
 * 非阻塞 仅仅做到了 等待数据过程中 的非阻塞， 对于数据的复制，仍然是阻塞的，因为想要把数据拿回来，就必须等待操作系统把数据从网卡拷贝到内存里
 * 多路复用 ==>
 * 用户态[selector.select()] select()方法会阻塞在内核态等待数据的过程中，如果内核态发现有准备好，可以读取的数据，select()就不阻塞了，也就是发生了可读事件
 * 之后select()返回一个key，并借助这个key进行数据的读取read(key.getChannel.read()) 同理，这个read()方法省略掉了数据的等待过程，但是数据从网卡复制到内存的过程
 * 仍然会导致线程阻塞，因为java程序不能直接操作网卡数据，只能依赖操作系统完成数据的拷贝、
 *
 * 多路复用的好处
 *
 * 阻塞IO：基于阻塞的模型，会导致各个 IO事件/连接事件 彼此互相干扰，如果由于一个线程而阻塞时，就不能进行其他操作
 * 多路复用：基于selector事件驱动，会不断阻塞，等待事件的发生，最后把事件封装为key，交给用户线程执行。
 * 可以看到，阻塞IO把等待数据和处理数据的工作交给一个人做
 * 而多路复用，把等待数据的阻塞工作交给Selector，而处理数据的工作才交给我们用户线程做。
 *
 * 信号驱动
 * 异步IO：
 * 异步/同步 ==>
 * 同步：线程自己去获取结果 (我们的用户线程 必须等待内核态把数据复制完，并把复制完的数据拿到)
 * 异步：线程自己不去获取结果，让其他线程获取结果。 [线程A发起read()方法，线程B完成数据的等待和 对数据的拷贝，此时线程A可以干别的事情]，此时线程B把已经
 * 复制到内存的数据，发送给A，A获取到了B的数据。
 * 可以看到：阻塞IO，非阻塞IO，多路复用 都是同步的。
 * 多路复用就是单线程+selector，只不过 线程A省略了 等待数据的阶段，直接等待数据的复制[网卡->内存]，然后再在内存里直接取数据
 *
 * 异步模型：
 *
 * 用户线程  ----Thread1[回调方法(参数接受结果)]---->         内核态
 *                                                      等待数据
 *                                                      复制数据
 * <---Thread2[回调方法(当事件完成后调用，并携带读取到的数据)]----
 *
 * 零拷贝问题
 * 需求：
 * 从文件读取一个字符串，然后通过socket发送到客户端
 * 涉及到IO操作 都设计系统调用，也就是内核态和用户态的相互切换。
 *
 * read()                               read()结束  write()调用
 * 用户态         ==>       内核态      ==> 用户态 ===> 内核态
 * 硬盘 ==> 操作系统缓冲区 ==> 用户缓冲区byte[] ==> Socket缓冲区 ==> 网卡
 *
 * 三次切换，四次拷贝
 *
 * NIO的优化：
 * 使用allocateDirect() 使用直接内存， 有些类似mmap。
 * 即相当于把 操作系统缓冲区和某一块用户缓冲区直接建立了映射
 * read()                                                  read()结束   write()方法
 * 磁盘 ===> 内核缓冲区(此内存映射到了用户缓冲区)[此缓冲区内核和用户都可以操作] ==> Socket缓冲区 ==> 网卡
 * 三次切换，三次拷贝
 *
 * 零拷贝：transferTo/From ==> 底层使用linux的sendFile
 * read()方法                                read()结束   write()开始  [其中，read()结束不会使得内核态转换为用户态，write()方法直接从内核态继续]
 * 磁盘 ==> 内核缓冲区 ==> 不经过java程序，也就是用户缓冲区 ==> socket缓冲区 ==> 网卡
 *
 *  一次切换，三次拷贝
 *
 *                ———————————— Socket缓冲区 [只有极少数的数据[比如数据的length offset] 会经过socket缓冲区]
 *  最终版本      |
 *  磁盘  ===> 内核缓冲区 ===> 网卡
 *  一次切换，两次拷贝 [零拷贝指的是，数据的拷贝不经过java程序]
 *
 *  DMA：解放CPU，直接内存访问。
 *  零拷贝不适合大量文件的拷贝。
 *  DMA就是不经过CPU的访存，什么样的访存可以不经过CPU呢？
 *  比如文件从硬盘读取到 内核缓冲区，
 *
 *
 *  异步IO：AIO
 *  真正的非阻塞，我们的多路复用只是做到了 使用一个selector解除了 用户线程在等待可用数据时的阻塞，但是用户线程复制线程时仍是阻塞的。
 *  注意：真正的AIO 需要依赖操作系统
 *  ==> Linux2.6 使用多路复用技术模拟了异步IO，性能没有优势
 *  Windows 通过IOCP实现了真正异步。 netty5.0引入了异步IO，但是由于 性能较差，维护成本高等，netty舍弃了5.0版本。
 *
 *
 */
public class Conclusion {
}
