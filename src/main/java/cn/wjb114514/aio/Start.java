package cn.wjb114514.aio;

/**
 * AIO编程模式 ： Reactor和Proactor
 * 基本原理是：事件发生时，服务器监听事件并处理
 * AIO也是异步不阻塞IO。特点是先有操作系统进行预处理，再创建线程进行处理
 *
 * 同步/异步 是线程上的概念，同步是指 如果不得到IO数据，就不能进行下一步的工作。而异步则是如果不得到IO数据，也可以进行下一步的工作
 * 比如ajax请求，用户不需要得到请求结果，仍可以操作页面[线程是通畅的]。如果设置为同步，则用户如果不能得到请求结果，整个页面就会等待请求结果，线程是卡住的。
 * 而阻塞/非阻塞可以看成是 IO操作和其他操作是不是阻塞的
 * 前面说了，异步的请求是无需等待结果仍可以进行相关操作的，因此ajax请求是异步非阻塞的。
 * 我们说的NIO是同步非阻塞，其实是把用户线程的工作分为两部分：一部分是IO事件，一部分是其他事件
 * 针对其他事件，和IO操作一点关系都没有，当然可以继续进行，这就是非阻塞的
 * 而对于IO事件，必须等到IO操作完了才能继续进行，你都是IO操作了，没有IO数据何谈IO操作，因此对于IO事件是阻塞的。
 * 非阻塞是指 IO事件和其他事件的分离，其他事件无需等到费时费力的IO事件做完了才能进行，而是在等待IO事件完成的过程中进行。
 * 同步是指IO操作必须等到请求结果才能继续进行。
 * 而ajax为什么是异步操作呢，主要是用户线程没有参与到IO事件，用户线程该干啥干啥，只需要一个ajax请求，就能把IO数据拿回来
 * 而NIO为什么是同步操作呢，主要是用户线程也参与到了IO事件，比如向服务器端下载数据，或者上传数据，必须要经过用户线程 的IO操作
 * 只不过相对于传统的BIO，NIO知道发生IO事件的时间，如果Selector发现了IO事件，就会通知用户线程，用户线程进入同步阻塞。但是没有IO事件的时候，用户线程干自己的，进入同步非阻塞。
 * 而BIO就是傻等着，没有IO事件也阻塞，有IO事件就更阻塞了，所以是同步阻塞的。
 * 最新的AIO，之所以叫异步非阻塞，应该是用户线程不需要参与到IO操作，费时费力的IO操作交给其他线程完成
 * 比如我们去理发，BIO就是啥也不干，直到轮到我们，NIO就是预约一下，先干别的，等到轮到我们了直接去理发。AIO就是有一个理发的想法，就瞬间理完发了
 * 理发的过程就是等待数据的过程，而轮到我们理发就是监听到了IO事件。我们必须先有IO事件，才能进行等待数据。
 * 所以一定要弄清楚两个概念： 等待IO事件，以及进行IO事件。进行IO事件涉及到系统调用，是费时费力的。而等待IO事件是完全可避免的，
 * NIO只做到了 去除没必要的等待IO事件的过程，而没做到去除进行IO事件的过程，也就是我们用户线程仍然需要自己进行IO事件，只不过用户线程直到什么时候该进行IO事件，不需要傻等着IO事件的发生
 */
public class Start {
}
