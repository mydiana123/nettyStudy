#### 黏包和半包现象

+ TCP/IP的处理都会存在黏包和半包问题
+ 滑动窗口:
  + 传统做法 ==> 发送端只有等到一条消息应答后，才能发送下一条[串行，吞吐量低]
  + 改进 ==> 设置一个窗口[一定大小的缓冲区]，可以多条数据发送，多条数据应答。一次发送的数据量不可以超过窗口大小。
+ 好处:
  1) 窗口起到一个缓冲区的作用，同时也起到一个流量控制的作用[通过缓冲区限制发送和接受的数据大小]
  2) 只有窗口的第一个应答回复，才会向下滑动，这样可以避免发送数据的丢失。比如目前窗口代表第2 3 4 5 条数据的发送，就算3 4 5条数据应答了，由于第2条数据没有应答，窗口依旧等待第二条数据的应答。这涉及到快重传机制
  3) 接收方也维护一个窗口，只有落在窗口内的数据才允许接受[此窗口的大小在报文里的Win字段里进行调整]
+ 和黏包半包的联系: 如果滑动窗口的容量不足以接受一条消息的全部，就会把此消息截断一部分，如果容量充足，会把多条报文堆积在一起。滑动窗口中缓冲了多个报文就会产生黏包
+ Nagle算法 ==> 会造成黏包。 IP和TCP层分别有20字节的报头。就算只有一个字节的主体，到达TCP层后，数据为41字节。Nagle算法会让尽可能多的数据发送，避免报文导致的传输率低[即延迟等待，尽量把多个及其小的包黏在一起发送出去]
+ 应用层 ==> 接收方的ByteBuf过大[netty默认1024]，造成黏包，ByteBuf的容量小于实际数据量，导致半包
+ MSS限制 ==> 以太网限制数据包大小MTU=1500,因此数据最多只能传输1460字节，这就导致大的数据会被切片为多个段[localhost是本机回环地址，不经过网卡[即不经过数字链路层]，所以没有MSS的限制]

补充
+ 滑动窗口的大小，在TCP报文的win字段里进行协商确定
+ 但是我们可以通过启动器的option()方法手动设置
+ // .option(ChannelOption.SO_SNDBUF) ==> 发送数据的缓冲区
  // .option(ChannelOption.SO_RCVBUF, 10) ==> 接受数据的缓冲区
+ 应用层缓冲区[ByteBuf]的默认大小为1024，我们也可以手动调整
+ childOption(ChannelOption.RCVBUF_ALLOCATOR, new AdaptiveRecvByteBufAllocator(16,16,16));

本质:TCP是流式协议，消息无边界

解决方案
1) 短连接
   1) 客户端发送一条数据后，就把连接断开。断开时服务器触发读事件，read方法返回-1，于是就可以判断消息发送完毕。 ==> 成功解决黏包问题
   2) 也就是说:就算可能存在nagle算法等，使得多条信息一同发送，可我们的短连接使得一条消息发完后，第二条就没机会再发了，因此解决黏包问题
   3) 问题:无法解决半包问题
2) netty提供的解码器处理器 FixedLengthFrameDecoder:定长解码器
   1) 工作方式:客户端和服务器端规定一条消息的长度，在服务器端的解码器 按照定长消息进行解码。
   2) 如果客户端的消息长度不够定长，需要用额外字符补充。
   3) 注意事项: 定长长度取决于客户端的最长信息，解码器处理器要在日志处理器之前
   4) 缺点: 不够时要补充占位字符，消耗较大。
3) 行解码器: LineBasedFrameDecoder ==> 使用分隔符界定边界。[\r\n 和 \n 都支持]
   1) 注意：需要指定最大长度，当读到最大长度还没找到分隔符时，抛异常 ==> 防止消息本身格式不正确/恶意攻击的消息
4) 自定义分隔符解码器 DelimiterBasedFrameDecoder 
   1) 上面两种的缺点:这两种解码器需要遍历发来的数据，以定位分割符，效率比较差。
5) LengthFieldBasedFrameDecoder ==> LTC Length Type Content 
   1) 和服务器规定好一条消息的格式，即一条消息不仅有消息内容，还有消息的长度。 ==> 如果出现了黏包/半包，会调整缓冲区使得一条消息是完整的
   2) 构造器参数:
      1) lengthFieldOffset: 长度字段在完成消息的偏移量 [长度字节之前可能包含魔数等附加信息，要定位到长度字节，需要跳过这些附加信息]
      2) lengthFieldLength: 长度字节本身的长度。 ==> 如果offset=0，length=2. 那么消息的[0,2)就是表示长度的两个字节
      3) lengthAdjustment: 从长度字节开始算，还有几个字节是内容 [还有几个字节，就是附加的字节，这个字段就是要把 这个附加字节给跳过]
      4) initialBytesToStrip: 需要过滤的消息内容，即此字段表示，裁剪消息的前几个字符
   3) 参数1的情况就是考虑到附加信息在长度字段前，而参数3的情况就是考虑附加信息在长度字段和内容之间
   4) 例子: 附加信息A[2B] 长度字节[3B] 附加信息B[1B] 内容[17B] ==> lengthFieldOffset=2,lengthFiledLength=3,lengthAdjustment=1.最后一个取决于我们需要的内容是什么